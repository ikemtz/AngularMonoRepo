{
  "ComponentMethodsTypeAhead": {
    "prefix": "imng-component-methods-type-ahead",
    "body": [
      "  public onTypeAheadSelected(match: ImngMatchSelectedEvent<I${1:EntityName}>) {",
      "  }",
      "  public onTypeAheadCleared(noMatches: boolean) {",
      "  }"
    ],
    "description": "ComponentMethodsTypeAhead"
  },
  "NgRxActionsDataEntry": {
    "prefix": "imng-ngrx-actions-data-entry",
    "body": [
      "export const clearCurrent$1 = createAction('[$2s] Clear Current $1');",
      "export const setCurrent$1 = createPayloadAction<I$1>('[$2s] Set Current $1');",
      "export const save$1Request = createPayloadAction<I$1>('[$2s] Save $1 Request');",
      "export const update$1Request = createPayloadAction<I$1>('[$2s] Update $1 Request');",
      "export const delete$1Request = createPayloadAction<I$1>('[$2s] Delete $1 Request');"
    ],
    "description": "NgRx Actions for Data Entry"
  },
  "NgRxActionsFailure": {
    "prefix": "imng-ngrx-actions-failure",
    "body": ["export const load$1sFailure = createPayloadAction<{ error: any }>(", "  '[$1s] Load $1s Failure');"],
    "description": "Create Exception Hanlder for Effects"
  },
  "NgRxActionsOData": {
    "prefix": "imng-ngrx-actions-odata",
    "body": [
      "export const load$1sRequest = createPayloadAction<ODataState>(",
      "'[$2s] Load $1s Request');",
      "export const load$1sSuccess = createPayloadAction<ODataResult<I$1>>(",
      "'[$2s] Load $1s Success',",
      ");"
    ],
    "description": "Create Load OData Request Success Action"
  },
  "NgRxActionsRequestSuccess": {
    "prefix": "imng-ngrx-actions-request-success",
    "body": [
      "export const ${1:CREATE_UPDATE_DELETE}Request = createPayloadAction<${2:REQUEST_TYPE}>(",
      "'[${3:FEATURE_NAME}s] ${1:CREATE_UPDATE_DELETE} Request');",
      "export const ${1:CREATE_UPDATE_DELETE}Success = createPayloadAction<${4:RESPONSE_TYPE}>(",
      "'[${3:FEATURE_NAME}s] ${1:CREATE_UPDATE_DELETE} Success',",
      ");"
    ],
    "description": "NgRxActionsRequestSuccess"
  },
  "NgRxEffectsDataEntry": {
    "prefix": "imng-ngrx-effects-data-entry",
    "body": [
      "  save$1Effect$ = createEffect(() =>",
      "    this.actions$.pipe(",
      "      ofType($2ActionTypes.save$1Request),",
      "      fetch({",
      "        run: (action: ReturnType<typeof $2ActionTypes.save$1Request>) =>",
      "          this.$2ApiService.post(action.payload).pipe(",
      "            withLatestFrom(this.store$),",
      "            map(([_, store]) =>",
      "              $2ActionTypes.load$1sRequest(store[from$1Reducer.$3S_FEATURE_KEY].gridODataState),",
      "            ),",
      "          ),",
      "        onError: this.exceptionHandler,",
      "      }),",
      "    ),",
      "  );",
      "  update$1Effect$ = createEffect(() =>",
      "    this.actions$.pipe(",
      "      ofType($2ActionTypes.update$1Request),",
      "      fetch({",
      "        run: (action: ReturnType<typeof $2ActionTypes.update$1Request>) =>",
      "          this.$2ApiService.put(action.payload).pipe(",
      "            withLatestFrom(this.store$),",
      "            map(([_, store]) =>",
      "              $2ActionTypes.load$1sRequest(store[from$1Reducer.$3S_FEATURE_KEY].gridODataState),",
      "            ),",
      "          ),",
      "        onError: this.exceptionHandler,",
      "      }),",
      "    ),",
      "  );",
      "  delete$1Effect$ = createEffect(() =>",
      "    this.actions$.pipe(",
      "      ofType($2ActionTypes.delete$1Request),",
      "      fetch({",
      "        run: (action: ReturnType<typeof $2ActionTypes.delete$1Request>) =>",
      "          this.$2ApiService.delete(action.payload).pipe(",
      "            withLatestFrom(this.store$),",
      "            map(([_, store]) =>",
      "              $2ActionTypes.load$1sRequest(store[from$1Reducer.$3S_FEATURE_KEY].gridODataState),",
      "            ),",
      "          ),",
      "        onError: this.exceptionHandler,",
      "      }),",
      "    ),",
      "  );"
    ],
    "description": "NgRxEffectsDataEntry"
  },
  "NgRxEffectsExceptionHandler": {
    "prefix": "imng-ngrx-effects-exception-handler",
    "body": [
      "private exceptionHandler(action, error) {",
      "  console.error('Error', error);  // NOSONAR",
      "  return $1ActionTypes.load$1sFailure({ error});",
      "}"
    ],
    "description": "Create Exception Hanlder for Effects"
  },
  "NgRxEffectsOData": {
    "prefix": "imng-ngrx-effects-odata",
    "body": [
      "load$1sEffect$ = createEffect(() =>",
      "    this.actions$.pipe(",
      "      ofType($2ActionTypes.load$1sRequest),",
      "      fetch({",
      "        run: (action: ReturnType<typeof $2ActionTypes.load$1sRequest>) =>",
      "          this.odataservice",
      "            .fetch<I$1>(env.endPoints.$4, action.payload)",
      "            .pipe(map(t => $2ActionTypes.load$1sSuccess(t))),",
      "        onError: this.exceptionHandler,",
      "      }),",
      "    ),",
      "  );"
    ],
    "description": "Create Load OData Request Effects"
  },
  "NgRxFacadeDataEntry": {
    "prefix": "imng-ngrx-facade-data-entry",
    "body": [
      "@Injectable()",
      "export class $1sDataEntryFacade implements IDataEntryFacade<I$1> {",
      "  constructor(private readonly store: Store<from$1Reducer.$2sPartialState>) { }",
      "  loading$ = this.store.pipe(select(queries.getLoading));",
      "  currentEntity$ = this.store.pipe(select(queries.getCurrentEntity));",
      "  isEditActive$ = this.store.pipe(select(queries.getIsEditActive));",
      "  isNewActive$ = this.store.pipe(select(queries.getIsNewActive));",
      "  clearCurrentEntity(): void {",
      "    this.store.dispatch(clearCurrent$1());",
      "  }",
      "  setCurrentEntity(entity: I$1, parentEntity?: unknown): void { ",
      "    this.store.dispatch(setCurrent$1(entity));",
      " }",
      "  saveNewEntity(entity: I$1): void {",
      "    this.store.dispatch(save$1Request(entity));",
      "  }",
      "  updateExistingEntity(entity: I$1): void {",
      "    this.store.dispatch(update$1Request(entity));",
      "  }",
      "}"
    ],
    "description": "NgRxFacadeDataEntry"
  },
  "NgRxFacadeLoadEntities": {
    "prefix": "imng-ngrx-facade-load-entities",
    "body": [
      " loadEntities(state: ODataState): void {",
      "this.store.dispatch($1ActionTypes.load$2sRequest(state));",
      "}"
    ],
    "description": "Create Load Entities method for Facades"
  },
  "NgRxFacadeTypeAhead": {
    "prefix": "imng-ngrx-facade-type-ahead",
    "body": [
      "import { Injectable } from '@angular/core';",
      "import { ImngTypeAheadFacade, ImngTypeaheadMatch, createTypeaheadFilters } from 'imng-ngxb-typeahead';",
      "import { Observable } from 'rxjs';",
      "import { Store, select } from '@ngrx/store';",
      "import { ODataState } from 'imng-kendo-odata';",
      "import { map, filter } from 'rxjs/operators';",
      "",
      "@Injectable({ providedIn: 'root' })",
      "export class $1TypeAheadFacade implements ImngTypeAheadFacade<I$1> {",
      "  matches$: Observable<ImngTypeaheadMatch<I$1>[]> = this.store.pipe(",
      "    select($2sQuery.get$1s),",
      "    filter(items => !!items),",
      "    map(items=> items.map(item => new ImngTypeaheadMatch<I$1>(item, item.name, false))),",
      "  );",
      "",
      "  loadMatches(filterCrieria: string): void {",
      "    const payload: ODataState = {",
      "      selectors: [$1Properties.ID, $1Properties.NAME],",
      "      filter: createTypeaheadFilters([$1Properties.NAME], filterCrieria),",
      "      take: 10,",
      "      count: false,",
      "    };",
      "    this.store.dispatch(actionTypes.load$1sRequest(payload));",
      "  }",
      "",
      "  constructor(private readonly store: Store<from$1Reducer.$3sPartialState>) { }",
      "}"
    ],
    "description": "NgRxFacadeTypeAhead"
  },
  "NgRxReducerDataEntry": {
    "prefix": "imng-ngrx-reducer-data-entry",
    "body": [
      "  on($1ActionTypes.setCurrent$2, (state, { payload }) => ({ ...state, current$2: payload })),",
      "  on($1ActionTypes.clearCurrent$2, state => ({ ...state, current$2: null })),",
      "  on(",
      "    $1ActionTypes.save$2Request,",
      "    $1ActionTypes.update$2Request,",
      "    $1ActionTypes.delete$2Request,",
      "    state => ({",
      "      ...state,",
      "      loading: true,",
      "    }),",
      "  ),"
    ],
    "description": "NgRxReducersDataEntry"
  },
  "NgRxReducerFailure": {
    "prefix": "imng-ngrx-reducer-failure",
    "body": ["  on($1ActionTypes.load$2sFailure, (state, { payload }) => ({ ...state, error: payload.error })),", ""],
    "description": "Create Reducer for failure action"
  },
  "NgRxReducerOData": {
    "prefix": "imng-ngrx-reducer-odata",
    "body": [
      " on($1ActionTypes.load$2sRequest, (state, { payload }) => ({",
      "    ...state,",
      "    gridODataState: payload,",
      "    loading: true,",
      "    error: null,",
      "  })),",
      "  on($1ActionTypes.load$2sSuccess, (state, { payload }) => ({",
      "    ...state,",
      "    loading: false,",
      "    gridPagerSettings: getODataPagerSettings({",
      "      gridData: payload,",
      "      gridODataState: state.gridODataState,",
      "    }),",
      "    $3: payload,",
      "    error: null,",
      "  })),"
    ],
    "description": "Create Reducer for OData Requests"
  },
  "NgRxSelectorsDataEntry": {
    "prefix": "imng-ngrx-selectors-data-entry",
    "body": [
      "export const getCurrent$1 = createSelector(",
      "  get$2sState,",
      "  state => state.current$1,",
      ");",
      "export const getIsEdit$1Active = createSelector(",
      "  getCurrent$1,",
      "  entity=> isTruthy(entity) && isTruthy(entity.id),",
      ");",
      "export const getIsNew$1Active = createSelector(",
      "  getCurrent$1,",
      "  entity=> isTruthy(entity) && !isTruthy(entity.id),",
      ");",
      "export const dataEntry$1Queries = {",
      "  getCurrent$1,",
      "  getIsEdit$1Active,",
      "  getIsNew$1Active,",
      "};"
    ],
    "description": "NgRx Selectors for Data Entry components"
  },
  "NgRxSelectorsGridOData": {
    "prefix": "imng-ngrx-selectors-grid-odata",
    "body": [
      "const get$1s = createSelector(get$1sState, state => state.gridData);",
      "const getLoading = createSelector(get$1sState, state => state.loading);",
      "const getGridODataState = createSelector(get$1sState, state => state.gridODataState);",
      "const getPagerSettings = createSelector(get$1sState, state => state.gridPagerSettings);",
      "export const odataGrid$1Queries = {",
      "  get$1s,",
      "  getLoading,",
      "  getGridODataState,",
      "  getPagerSettings,",
      "};"
    ],
    "description": "NgRxSelectorsGridOData"
  },
  "ServicesDataEntry": {
    "prefix": "imng-services-data-entry",
    "body": [
      "@Injectable({",
      "  providedIn: 'root',",
      "})",
      "export class $1Service extends NrsrxBaseApiClientService<I$2> {",
      "  url: string = environment.endPoints.$3Api;",
      "  constructor(http: HttpClient) {",
      "    super(http);",
      "  }",
      "}"
    ],
    "description": "ServicesDataEntry"
  },
  "SpecNgRxFacadeLoadEntities": {
    "prefix": "imng-spec-ngrx-facade-load-entities",
    "body": [
      "   it('loadEntities() should return empty list with loaded == true', async done => {",
      "      try {",
      "        let list = await readFirst(facade.gridData$);",
      "        let isloading = await readFirst(facade.loading$);",
      "",
      "        const client: ODataService = TestBed.inject(ODataService);",
      "        const response = cold('-a-|', {",
      "          a: { data: [{ id: 'i ❤' }, { id: 'imng' }, { id: '💯' }], total: 3 },",
      "        });",
      "        client.fetch = jest.fn(() => response);",
      "",
      "        expect(list.data.length).toBe(0);",
      "        expect(isloading).toBe(false);",
      "        facade.loadEntities({});",
      "",
      "        list = await readFirst(facade.gridData$);",
      "        isloading = await readFirst(facade.loading$);",
      "",
      "        expect(list.data.length).toBe(0);",
      "        expect(isloading).toBe(true);",
      "",
      "        done();",
      "      } catch (err) {",
      "        done.fail(err);",
      "      }",
      "    });"
    ],
    "description": "Create unit for facade load Entities"
  },
  "SpecNgRxFacadeSaveEntities": {
    "prefix": "imng-spec-ngrx-facade-save-entities",
    "body": [
      "it('should save data', async done =>",
      "  await testSaveCurrentEntity<$1Facade>(done, facade, TestBed.inject(HttpClient)));"
    ],
    "description": "SpecNgRxFacadeSaveEntities"
  },
  "SpecNgRxFacadeUpdateEntities": {
    "prefix": "imng-spec-ngrx-facade-update-entities",
    "body": [
      "it('should update data', async done =>",
      "  await testUpdateCurrentEntity<$1Facade>(done, facade, TestBed.inject(HttpClient)));"
    ],
    "description": "SpecNgRxFacadeUpdateEntities"
  },
  "SpecNgRxFacadeTypeAhead": {
    "prefix": "imng-spec-ngrx-facade-type-ahead",
    "body": [
      "import { NgModule } from '@angular/core';",
      "import { TestBed } from '@angular/core/testing';",
      "import { HttpClientTestingModule } from '@angular/common/http/testing';",
      "import { EffectsModule } from '@ngrx/effects';",
      "import { StoreModule, Store } from '@ngrx/store';",
      "import { NxModule } from '@nrwl/angular';",
      "import { HttpClient } from '@angular/common/http';",
      "import { readFirst } from 'imng-ngrx-utils/testing';",
      "import { ODataService } from 'imng-kendo-odata';",
      "import { of } from 'rxjs';",
      "",
      "interface TestSchema {",
      "  ${1:NgRxFeatureName}s: ${2:StateName}sState;",
      "}",
      "",
      "describe('${3:EntityName_Pascal}TypeAheadFacade', () => {",
      "  let facade: ${3:EntityName_Pascal}TypeAheadFacade;",
      "  let store: Store<TestSchema>;",
      "  let httpClient: HttpClient;",
      "",
      "  beforeEach(() => {});",
      "",
      "  describe('used in NgModule', () => {",
      "    beforeEach(() => {",
      "      @NgModule({",
      "        imports: [",
      "          StoreModule.forFeature('${1:NgRxFeatureName}s', ${1:NgRxFeatureName}sReducer, { initialState }),",
      "          EffectsModule.forFeature([${2:StateName}sEffects]),",
      "          HttpClientTestingModule,",
      "        ],",
      "        providers: [${3:EntityName_Pascal}TypeAheadFacade],",
      "      })",
      "      class CustomFeatureModule {}",
      "",
      "      @NgModule({",
      "        imports: [",
      "          NxModule.forRoot(),",
      "          StoreModule.forRoot({}, { runtimeChecks: ngrxRunTimeChecks }),",
      "          EffectsModule.forRoot([]),",
      "          CustomFeatureModule,",
      "        ],",
      "      })",
      "      class RootModule {}",
      "      TestBed.configureTestingModule({ imports: [RootModule] });",
      "",
      "      store = TestBed.inject(Store);",
      "      httpClient = TestBed.inject(HttpClient);",
      "      facade = TestBed.inject(${3:EntityName_Pascal}TypeAheadFacade);",
      "    });",
      "",
      "    it('load${3:EntityName_Pascal}s() should execute http Get', async done => {",
      "      try {",
      "        const getSpy = jest.spyOn(httpClient, \"get\");",
      "        facade.loadMatches('🎂 🍩 😡');",
      "        expect(getSpy).toBeCalledWith(\"${4:ODataUrl}?\\$filter=(contains(name,'%F0%9F%8E%82') or contains(name,'%F0%9F%8D%A9') or contains(name,'%F0%9F%98%A1'))&\\$top=10&\\$select=id,name\");",
      "        expect(getSpy).toBeCalledTimes(1);",
      "        done();",
      "      } catch (err) {",
      "        done.fail(err);",
      "      }",
      "    });",
      "",
      "    it('load${3:EntityName_Pascal}s() should execute odata fetch', async done => {",
      "      try {",
      "        const oDataService = TestBed.inject(ODataService);",
      "        oDataService.fetch = jest.fn(() => of({ data: [{ id: '👼', [${3:EntityName}Properties.NAME]: '👿🕺' }], total: 500 }));",
      "",
      "        facade.loadMatches('🎂 🍩 😡');",
      "        expect(oDataService.fetch).toBeCalledWith('${4:ODataUrl}', {",
      "          count: false,",
      "          filter: {",
      "            filters: [",
      "              { field: ${3:EntityName}Properties.NAME, operator: 'contains', value: '🎂' },",
      "              { field: ${3:EntityName}Properties.NAME, operator: 'contains', value: '🍩' },",
      "              { field: ${3:EntityName}Properties.NAME, operator: 'contains', value: '😡' },",
      "            ],",
      "            logic: 'or',",
      "          },",
      "          selectors: ['id', ${3:EntityName}Properties.NAME],",
      "          take: 10,",
      "        });",
      "        expect(oDataService.fetch).toBeCalledTimes(1);",
      "        const matches = await readFirst(facade.matches$);",
      "        expect(matches).toEqual([{ header: false, item: { id: '👼', [${3:EntityName}Properties.NAME]: '👿🕺' }, value: '👿🕺' }]);",
      "        done();",
      "      } catch (err) {",
      "        done.fail(err);",
      "      }",
      "    });",
      "  });",
      "});",
      ""
    ],
    "description": "SpecNgRxFacadeTypeAhead"
  }
}

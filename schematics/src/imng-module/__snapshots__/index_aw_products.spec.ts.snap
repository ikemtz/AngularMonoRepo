// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`imng-module actions should work 1`] = `
"import { createAction } from '@ngrx/store';
import { ODataResult, ODataState } from 'imng-kendo-odata';
import { createPayloadAction } from 'imng-ngrx-utils';

export const loadProductsRequest = createPayloadAction<ODataState>(
    '[Products] Load Products Request');
export const loadProductsSuccess = createPayloadAction<ODataResult<IProduct>>(
    '[Products] Load Products Success');
export const reloadProductsRequest = createAction(
    '[Products] Reload Products Request');
export const reloadProductsSuccess = createPayloadAction<ODataResult<IProduct>>(
    '[Products] Reload Products Success');

export const clearCurrentProduct = createAction('[Products] Clear Current Product');
export const setCurrentProduct = createPayloadAction<IProduct>('[Products] Set Current Product');
export const saveProductRequest = createPayloadAction<IProduct>('[Products] Save Product Request');
export const updateProductRequest = createPayloadAction<IProduct>('[Products] Update Product Request');
export const deleteProductRequest = createPayloadAction<IProduct>('[Products] Delete Product Request');

export const loadProductModelsRequest = createPayloadAction<ODataState>(
    '[Products] Load ProductModels Request');
export const loadProductModelsSuccess = createPayloadAction<ODataResult<IProductModel>>(
    '[Products] Load ProductModels Success');
export const loadProductCategoriesRequest = createPayloadAction<ODataState>(
    '[Products] Load ProductCategories Request');
export const loadProductCategoriesSuccess = createPayloadAction<ODataResult<IProductCategory>>(
    '[Products] Load ProductCategories Success');
"
`;

exports[`imng-module add component spec template should work 1`] = `
"import { CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA } from '@angular/core';
import { waitForAsync, ComponentFixture, TestBed } from '@angular/core/testing';
import { ReactiveFormsModule } from '@angular/forms';
import { NoopAnimationsModule } from '@angular/platform-browser/animations';
import { DatePickerModule } from '@progress/kendo-angular-dateinputs';
import { DropDownsModule } from '@progress/kendo-angular-dropdowns';
import { createDataEntryMockFacade } from 'imng-kendo-data-entry/testing';
import { mockConsoleError, mockConsoleGroup, mockConsoleWarn, readFirst } from 'imng-ngrx-utils/testing';
import { of } from 'rxjs';

import { ProductAddComponent } from './add.component';
import { ProductCrudFacade } from './crud.facade';

export function createMockProductFacade() {
  return {
    currentEntity$: of({}),
    productModels$: of([
      { id: 'abc',name: 'abc',description: 'abc', },
      { id: 'xyz',name: 'xyz',description: 'xyz', },]),
    loadProductModels: jest.fn(),
    productCategories$: of([
      { id: 'abc',name: 'abc', },
      { id: 'xyz',name: 'xyz', },]),
    loadProductCategories: jest.fn(),
  };
}

describe('ProductAddComponent', () => {
  let component: ProductAddComponent;
  let fixture: ComponentFixture<ProductAddComponent>;
  let facade: ProductCrudFacade;
  let consoleWarnMock: jest.SpyInstance<void>;
  let consoleGroupMock: jest.SpyInstance<void>;

  beforeEach(waitForAsync(() => {
    consoleWarnMock = mockConsoleWarn();
    consoleGroupMock = mockConsoleGroup();
    TestBed.configureTestingModule({
      declarations: [ProductAddComponent],
      imports: [ReactiveFormsModule, NoopAnimationsModule, DatePickerModule, DropDownsModule, ],
      providers: [{ provide: ProductCrudFacade, useValue: createDataEntryMockFacade(createMockProductFacade()) }],
      schemas: [CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA],
    }).compileComponents();
  }));

  beforeEach(() => {
    fixture = TestBed.createComponent(ProductAddComponent);
    component = fixture.componentInstance;
    facade = TestBed.inject(ProductCrudFacade);
    fixture.detectChanges();
  });

  afterAll(() => {
    component.ngOnDestroy();
    consoleWarnMock.mockRestore();
    consoleGroupMock.mockRestore();
  });

  test('should create', () => {
    expect(component).toBeTruthy();
  });

  test('should save', () => {
    component.initForm();
    component.addEditForm?.patchValue(createTestProduct());
    component.addEditForm.controls.productModel?.patchValue(createTestProductModel());
    component.addEditForm.controls.productCategory?.patchValue(createTestProductCategory());

    let item: IProduct | undefined;
    facade.saveNewEntity = jest.fn(x => (item = x));
    facade.updateExistingEntity = jest.fn();
    expect(component.getFormErrors()).toStrictEqual([]);
    component.onSubmit();
    expect(facade.saveNewEntity).toHaveBeenCalledTimes(1);
    expect(facade.updateExistingEntity).toHaveBeenCalledTimes(0);

    expect(item).toMatchSnapshot({
      sellStartDate: expect.any(Date),
      sellEndDate: expect.any(Date),
      discontinuedDate: expect.any(Date),
    });

  });

  /**
   * Note: if this test fails, then you're missing validators in your forms.
   * Using form validators is typically a good idea.
   */
  test('should not save', () => {
    const consoleErrorMock = mockConsoleError();
    component.addEditForm?.patchValue({});
    component.onSubmit();
    expect(facade.saveNewEntity).toHaveBeenCalledTimes(0);
    expect(facade.updateExistingEntity).toHaveBeenCalledTimes(0);
    consoleErrorMock.mockRestore();
  });

  test('should cancel', () => {
    facade.clearCurrentEntity = jest.fn();
    component.cancel();
    expect(facade.clearCurrentEntity).toHaveBeenCalledTimes(1);
  });

  test('should support ProductModel filters', async () => {
    component.handleProductModelFilter('xy');
    const result = await readFirst(component.productModels$);
    expect(result).toMatchSnapshot();
  });

  test('should support ProductCategory filters', async () => {
    component.handleProductCategoryFilter('xy');
    const result = await readFirst(component.productCategories$);
    expect(result).toMatchSnapshot();
  });
});
"
`;

exports[`imng-module add component template should work 1`] = `
"import { Component, ChangeDetectionStrategy, OnInit, OnDestroy } from '@angular/core';
import { ProductCrudFacade } from './crud.facade';
import { ProductBaseEntryComponent } from './base-entry.component';

@Component({
  selector: 'aw-product-add',
  templateUrl: './add-edit.component.html',
  styleUrls: ['./add-edit.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush,
  standalone: false,
})
export class ProductAddComponent extends ProductBaseEntryComponent implements OnInit, OnDestroy {
  public dialogTitle = 'Add Product';
  public active$ = this.facade.isNewActive$;

  constructor(facade: ProductCrudFacade) {
    super(facade);
  }
  public override initForm(): void {
    super.initForm();
    this.addEditForm.patchValue({});
  }

  public save(): void {
    const val = this.addEditForm.value;
    val.id = undefined;
    this.facade.saveNewEntity(val);
  }
}
"
`;

exports[`imng-module base crud component should work 1`] = `
"import { OnInit, Component } from '@angular/core';
import { FormGroup } from '@angular/forms';
import { BaseDataEntryComponent } from 'imng-kendo-data-entry';
import { BehaviorSubject, map, Observable, switchMap } from 'rxjs';

import { ProductCrudFacade } from './crud.facade';

@Component({ 
  template: '',
  standalone: false, 
})
export abstract class ProductBaseEntryComponent extends BaseDataEntryComponent<ProductCrudFacade>
  implements OnInit {
  public readonly props = ProductProperties;
  public readonly productModelProps = ProductModelProperties;
  public readonly productModels$: Observable<IProductModel[]>;
  public readonly productModelFilter$ = new BehaviorSubject('');
  public readonly productCategoryProps = ProductCategoryProperties;
  public readonly productCategories$: Observable<IProductCategory[]>;
  public readonly productCategoryFilter$ = new BehaviorSubject('');
  public addEditForm: FormGroup<IProductForm>;

  constructor(facade: ProductCrudFacade) {
    super(facade);
    this.productModels$ = facade.productModels$.pipe(
      switchMap(productModels => this.productModelFilter$.pipe(
        map(productModelFilter => productModelFilter ? productModels
          .filter(productModel => (
            (productModel.name && productModel.name.toLowerCase().indexOf(productModelFilter) >= 0) ||
            (productModel.description && productModel.description.toLowerCase().indexOf(productModelFilter) >= 0)
          )) : productModels
    ))));
    this.productCategories$ = facade.productCategories$.pipe(
      switchMap(productCategories => this.productCategoryFilter$.pipe(
        map(productCategoryFilter => productCategoryFilter ? productCategories
          .filter(productCategory => (
            (productCategory.name && productCategory.name.toLowerCase().indexOf(productCategoryFilter) >= 0)
          )) : productCategories
    ))));
  }

  public override ngOnInit(): void {
    this.initForm();
    this.facade.loadProductModels({ selectors: [
      ProductModelProperties.ID,
      ProductModelProperties.NAME,
      ProductModelProperties.DESCRIPTION,] });
    this.facade.loadProductCategories({ selectors: [
      ProductCategoryProperties.ID,
      ProductCategoryProperties.NAME,] });
  }

  public initForm(): void {
    this.addEditForm = ProductFormGroupFac();
  }

  public cancel(): void {
    this.facade.clearCurrentEntity();
  }

  public handleProductModelFilter(value: string) {
    this.productModelFilter$.next(value.toLowerCase());
  }
  public handleProductCategoryFilter(value: string) {
    this.productCategoryFilter$.next(value.toLowerCase());
  }
}
"
`;

exports[`imng-module crud facade spec template should work 1`] = `
"import { NgModule } from '@angular/core';
import { TestBed } from '@angular/core/testing';
import { HttpClient } from '@angular/common/http';
import { EffectsModule } from '@ngrx/effects';
import { StoreModule, Store } from '@ngrx/store';
import { readFirst } from 'imng-ngrx-utils/testing';
import {
  testAddSetAndClearCurrentEntity,
  testEditSetAndClearCurrentEntity,
  testSaveCurrentEntity,
  testUpdateCurrentEntity,
} from 'imng-kendo-data-entry/testing';
import { createODataPayload } from 'imng-kendo-odata';
import { of } from 'rxjs';

import { productsFeature, ProductListEffects, ProductCrudEffects } from '../+state';
import { ProductCrudFacade } from './crud.facade';
import { ProductApiService } from './api.service';
import { environment } from '@env';

describe('ProductCrudFacade', () => {
  let facade: ProductCrudFacade;
  let store: Store;
  let httpClient: HttpClient;

  // eslint-disable-next-line @typescript-eslint/no-empty-function
  beforeEach(() => {}); //NOSONAR

  describe('used in NgModule', () => {
    beforeEach(() => {
      @NgModule({
        imports: [
          StoreModule.forFeature(productsFeature),
          EffectsModule.forFeature([ProductListEffects, ProductCrudEffects]),
        ],
        providers: [
          ProductCrudFacade,
          ProductApiService,
          { provide: HttpClient, useValue: { get: jest.fn(() => of(createODataPayload([createTestProduct()]))) } },
        ],
      })
      class CustomFeatureModule {}

      @NgModule({
        imports: [
          StoreModule.forRoot({}, { runtimeChecks: environment.runtimeChecks }),
          EffectsModule.forRoot([]),
          CustomFeatureModule,
        ],
      })
      class RootModule {}
      TestBed.configureTestingModule({ imports: [RootModule] });

      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      store = TestBed.inject(Store);
      facade = TestBed.inject(ProductCrudFacade);
      httpClient = TestBed.inject(HttpClient);
    });

    test('clearCurrentEntity() should set currentProduct to null', async () => {
      let isNewActive = await readFirst(facade.isNewActive$);
      expect(isNewActive).toBeFalsy();

      facade.clearCurrentEntity();
      isNewActive = await readFirst(facade.isNewActive$);

      expect(isNewActive).toBeFalsy();
      expect(await readFirst(store)).toMatchSnapshot();
    });

    test('New Entity Set And Clear CurrentEntity', async () =>
      testAddSetAndClearCurrentEntity<ProductCrudFacade>(facade));
    test('Existing Entity Set And Clear CurrentEntity', async () =>
      testEditSetAndClearCurrentEntity<ProductCrudFacade>(facade));
    test('Save CurrentEntity', async () =>
      testSaveCurrentEntity<ProductCrudFacade>(facade, httpClient));
    test('Update CurrentEntity', async () =>
      testUpdateCurrentEntity<ProductCrudFacade>(facade, httpClient));

    test('should load ProductModels', async () => {
      facade.loadProductModels({});
      expect(httpClient.get).toHaveBeenCalledTimes(1);
      const result = await readFirst(facade.productModels$);
      expect(result.length).toBe(1);
    });

    test('should load ProductCategories', async () => {
      facade.loadProductCategories({});
      expect(httpClient.get).toHaveBeenCalledTimes(1);
      const result = await readFirst(facade.productCategories$);
      expect(result.length).toBe(1);
    });
  });
});
"
`;

exports[`imng-module crud facade template should work 1`] = `
"import { Injectable } from '@angular/core';
import { Store } from '@ngrx/store';
import { IDataEntryFacade } from 'imng-kendo-data-entry';
import { ODataState } from 'imng-kendo-odata';
import { productsFeature, productSelectors, productActionTypes } from '../+state';

@Injectable()
export class ProductCrudFacade implements IDataEntryFacade<IProduct> {
  loading$ = this.store.select(productsFeature.selectLoading);
  currentEntity$ = this.store.select(productsFeature.selectCurrentProduct);
  isEditActive$ = this.store.select(productSelectors.selectIsEditProductActive);
  isNewActive$ = this.store.select(productSelectors.selectIsNewProductActive);
  productModels$ = this.store.select(productsFeature.selectProductModels);
  productCategories$ = this.store.select(productsFeature.selectProductCategories);

  constructor(private readonly store: Store) {}

  public setCurrentEntity(item: IProduct): void {
    this.store.dispatch(productActionTypes.setCurrentProduct(item));
  }

  public clearCurrentEntity(): void {
    this.store.dispatch(productActionTypes.clearCurrentProduct());
  }

  public saveNewEntity(item: IProduct): void {
    this.store.dispatch(productActionTypes.saveProductRequest(item));
  }

  public updateExistingEntity(item: IProduct): void {
    this.store.dispatch(productActionTypes.updateProductRequest(item));
  }

  public loadProductModels(state: ODataState): void {
    this.store.dispatch(productActionTypes.loadProductModelsRequest(state));
  }
  public loadProductCategories(state: ODataState): void {
    this.store.dispatch(productActionTypes.loadProductCategoriesRequest(state));
  }
}
"
`;

exports[`imng-module crud html template should work 1`] = `
"<imng-data-entry-dialog id="dataEntryProducts" name="dataEntryProducts" [width]="700" [height]="550" [parentComponent]="this" autoFocusedElement="#name">
  <form id="imng-form" novalidate [formGroup]="addEditForm" autocomplete="off" class="row needs-validation">
    <div class="col-md-6">
      <label for="id" class="control-label">Id: <span class="text-danger">*</span></label>
      <input id="id" type="text" class="form-control" [formControlName]="props.ID" />
      @if ((submitted$ | async) && formControlErrors(props.ID)) {
        <div class="invalid-feedback d-block">
        @if (formControlErrors(props.ID)?.[RequiredError]) {
          <div>Product id is required</div>
        }
        </div>
      }
    </div>
    <div class="col-md-6">
      <label for="name" class="control-label">Name: <span class="text-danger">*</span></label>
      <input id="name" type="text" class="form-control" [formControlName]="props.NAME" />
      @if ((submitted$ | async) && formControlErrors(props.NAME)) {
        <div class="invalid-feedback d-block">
        @if (formControlErrors(props.NAME)?.[RequiredError]) {
          <div>Product name is required</div>
        }
        @if (formControlErrors(props.NAME)?.[MinLengthError]) {
          <div>
            Product name requires a min length of
            {{formMinLengthError(props.NAME)?.requiredLength}}, currently only
            {{formMinLengthError(props.NAME)?.actualLength}}.
          </div>
        }
        </div>
      }
    </div>
    <div class="col-md-6">
      <label for="num" class="control-label">Num: <span class="text-danger">*</span></label>
      <input id="num" type="text" class="form-control" [formControlName]="props.NUM" />
      @if ((submitted$ | async) && formControlErrors(props.NUM)) {
        <div class="invalid-feedback d-block">
        @if (formControlErrors(props.NUM)?.[RequiredError]) {
          <div>Product num is required</div>
        }
        @if (formControlErrors(props.NUM)?.[MinLengthError]) {
          <div>
            Product num requires a min length of
            {{formMinLengthError(props.NUM)?.requiredLength}}, currently only
            {{formMinLengthError(props.NUM)?.actualLength}}.
          </div>
        }
        </div>
      }
    </div>
    <div class="col-md-6">
      <label for="color" class="control-label">Color:</label>
      <input id="color" type="text" class="form-control" [formControlName]="props.COLOR" />
        @if ((submitted$ | async) && formControlErrors(props.COLOR)) {
          <div class="invalid-feedback d-block">
          @if (formControlErrors(props.COLOR)?.[MinLengthError]) {
            <div>
              Product color requires a min length of
              {{formMinLengthError(props.COLOR)?.requiredLength}}, currently only
              {{formMinLengthError(props.COLOR)?.actualLength}}.
            </div>
          }
          </div>
        }
      </div>
    <div class="col-md-6">
      <label for="standard_cost" class="control-label">Standard Cost: <span class="text-danger">*</span></label>
      <input id="standard_cost" type="number" class="form-control" [formControlName]="props.STANDARD_COST" />
      @if ((submitted$ | async) && formControlErrors(props.STANDARD_COST)) {
        <div class="invalid-feedback d-block">
        @if (formControlErrors(props.STANDARD_COST)?.[RequiredError]) {
          <div>Product standard cost is required</div>
        }
        </div>
      }
    </div>
    <div class="col-md-6">
      <label for="list_price" class="control-label">List Price: <span class="text-danger">*</span></label>
      <input id="list_price" type="number" class="form-control" [formControlName]="props.LIST_PRICE" />
      @if ((submitted$ | async) && formControlErrors(props.LIST_PRICE)) {
        <div class="invalid-feedback d-block">
        @if (formControlErrors(props.LIST_PRICE)?.[RequiredError]) {
          <div>Product list price is required</div>
        }
        </div>
      }
    </div>
    <div class="col-md-6">
      <label for="size" class="control-label">Size:</label>
      <input id="size" type="text" class="form-control" [formControlName]="props.SIZE" />
    </div>
    <div class="col-md-6">
      <label for="weight" class="control-label">Weight:</label>
      <input id="weight" type="number" class="form-control" [formControlName]="props.WEIGHT" />
    </div>
    <div class="col-md-6">
      <label for="product_category_id" class="control-label">Product Category Id:</label>
      <input id="product_category_id" type="text" class="form-control" [formControlName]="props.PRODUCT_CATEGORY_ID" />
    </div>
    <div class="col-md-6">
      <label for="product_model_id" class="control-label">Product Model Id:</label>
      <input id="product_model_id" type="text" class="form-control" [formControlName]="props.PRODUCT_MODEL_ID" />
    </div>
    <div class="col-md-6">
      <label for="sell_start_date" class="control-label">Sell Start Date: <span class="text-danger">*</span></label>
      <kendo-datepicker id="sell_start_date" class="form-control" [formControlName]="props.SELL_START_DATE" />
      @if ((submitted$ | async) && formControlErrors(props.SELL_START_DATE)) {
        <div class="invalid-feedback d-block">
        @if (formControlErrors(props.SELL_START_DATE)?.[RequiredError]) {
          <div>Product sell start date is required</div>
        }
        </div>
      }
    </div>
    <div class="col-md-6">
      <label for="sell_end_date" class="control-label">Sell End Date:</label>
      <kendo-datepicker id="sell_end_date" class="form-control" [formControlName]="props.SELL_END_DATE"></kendo-datepicker>
    </div>
    <div class="col-md-6">
      <label for="discontinued_date" class="control-label">Discontinued Date:</label>
      <kendo-datepicker id="discontinued_date" class="form-control" [formControlName]="props.DISCONTINUED_DATE"></kendo-datepicker>
    </div>
    <div class="col-md-6">
      <label for="thumb_nail_photo" class="control-label">Thumb Nail Photo:</label>
      <input id="thumb_nail_photo" type="text" class="form-control" [formControlName]="props.THUMB_NAIL_PHOTO" />
    </div>
    <div class="col-md-6">
      <label for="product_model" class="control-label">Product Model:</label>
      <kendo-multicolumncombobox
        id="product_model"
        placeholder="Select a product model..."
        [formControlName]="props.PRODUCT_MODEL_ID"
        [data]="productModels$ | async"
        [textField]="productModelProps.NAME"
        [valueField]="productModelProps.ID"
        [valuePrimitive]="true"
        [filterable]="true"
        (filterChange)="handleProductModelFilter($event)">
          <kendo-combobox-column field="name" title="Name" [width]="100"></kendo-combobox-column>
          <kendo-combobox-column field="description" title="Description" [width]="100"></kendo-combobox-column>
      </kendo-multicolumncombobox>
    </div>
    <div class="col-md-6">
      <label for="product_category" class="control-label">Product Category:</label>
      <kendo-multicolumncombobox
        id="product_category"
        placeholder="Select a product category..."
        [formControlName]="props.PRODUCT_CATEGORY_ID"
        [data]="productCategories$ | async"
        [textField]="productCategoryProps.NAME"
        [valueField]="productCategoryProps.ID"
        [valuePrimitive]="true"
        [filterable]="true"
        (filterChange)="handleProductCategoryFilter($event)">
          <kendo-combobox-column field="name" title="Name" [width]="100"></kendo-combobox-column>
      </kendo-multicolumncombobox>
    </div>
  </form>
</imng-data-entry-dialog>
"
`;

exports[`imng-module edit component spec template should work 1`] = `
"import { CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA } from '@angular/core';
import { waitForAsync, ComponentFixture, TestBed } from '@angular/core/testing';
import { ReactiveFormsModule } from '@angular/forms';
import { NoopAnimationsModule } from '@angular/platform-browser/animations';
import { DatePickerModule } from '@progress/kendo-angular-dateinputs';
import { DropDownsModule } from '@progress/kendo-angular-dropdowns';
import { createDataEntryMockFacade } from 'imng-kendo-data-entry/testing';
import { mockConsoleError, mockConsoleGroup, mockConsoleWarn, readFirst } from 'imng-ngrx-utils/testing';
import { createMockProductFacade } from './add.component.spec';
import { ProductEditComponent } from './edit.component';
import { ProductCrudFacade } from './crud.facade';

describe('ProductEditComponent', () => {
  let component: ProductEditComponent;
  let fixture: ComponentFixture<ProductEditComponent>;
  let facade: ProductCrudFacade;
  let consoleWarnMock: jest.SpyInstance<void>;
  let consoleGroupMock: jest.SpyInstance<void>;

  beforeEach(waitForAsync(() => {
    consoleWarnMock = mockConsoleWarn();
    consoleGroupMock = mockConsoleGroup();
    TestBed.configureTestingModule({
      declarations: [ProductEditComponent],
      imports: [ReactiveFormsModule, NoopAnimationsModule, DatePickerModule, DropDownsModule, ],
      providers: [{ provide: ProductCrudFacade, useValue: createDataEntryMockFacade(createMockProductFacade()) }],
      schemas: [CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA],
    }).compileComponents();
  }));

  beforeEach(() => {
    fixture = TestBed.createComponent(ProductEditComponent);
    component = fixture.componentInstance;
    facade = TestBed.inject(ProductCrudFacade);
    fixture.detectChanges();
  });

  afterAll(() => {
    component.ngOnDestroy();
    consoleWarnMock.mockRestore();
    consoleGroupMock.mockRestore();
  });

  test('should update', () => {
    component.initForm();
    component.addEditForm.patchValue(createTestProduct());
    let item: IProduct | undefined;
    facade.updateExistingEntity = jest.fn(x => (item = x));
    expect(component.getFormErrors()).toStrictEqual([]);
    component.onSubmit();
    expect(facade.saveNewEntity).toHaveBeenCalledTimes(0);
    expect(facade.updateExistingEntity).toHaveBeenCalledTimes(1);

    expect(item).toMatchSnapshot({
      sellStartDate: expect.any(Date),
      sellEndDate: expect.any(Date),
      discontinuedDate: expect.any(Date),
    });

  });

  /**
   * Note: if this test fails, then you're missing validators in your forms.
   * Using form validators is typically a good idea.
   */
  test('should not update', () => {
    const consoleErrorMock = mockConsoleError();
    component.addEditForm?.patchValue({});
    component.onSubmit();
    expect(facade.saveNewEntity).toHaveBeenCalledTimes(0);
    expect(facade.updateExistingEntity).toHaveBeenCalledTimes(0);
    consoleErrorMock.mockRestore();
  });

  test('should cancel', () => {
    component.cancel();
    expect(facade.clearCurrentEntity).toHaveBeenCalledTimes(1);
  });

  test('should support ProductModel filters', async () => {
    component.handleProductModelFilter('xy');
    const result = await readFirst(component.productModels$);
    expect(result).toStrictEqual([{ id: 'xyz',name: 'xyz',description: 'xyz', }]);
  });

  test('should support ProductCategory filters', async () => {
    component.handleProductCategoryFilter('xy');
    const result = await readFirst(component.productCategories$);
    expect(result).toStrictEqual([{ id: 'xyz',name: 'xyz', }]);
  });


});
"
`;

exports[`imng-module edit component template should work 1`] = `
"import { Component, ChangeDetectionStrategy, OnInit, OnDestroy } from '@angular/core';
import { formGroupPatcher } from 'imng-kendo-data-entry';

import { ProductBaseEntryComponent } from './base-entry.component';
import { ProductCrudFacade } from './crud.facade';

@Component({
  selector: 'aw-product-edit',
  templateUrl: './add-edit.component.html',
  styleUrls: ['./add-edit.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush,
  standalone: false,
})
export class ProductEditComponent extends ProductBaseEntryComponent implements OnInit, OnDestroy {
  public dialogTitle = 'Edit Product';
  public active$ = this.facade.isEditActive$;

  constructor(facade: ProductCrudFacade) {
    super(facade);
  }
  public override initForm(): void {
    super.initForm();
    if (this.addEditForm) {
      this.allSubscriptions.push(this.facade.currentEntity$.pipe(formGroupPatcher(this.addEditForm)).subscribe());
    }
  }

  public save(): void {
    const val = this.addEditForm.value;
    this.facade.updateExistingEntity(val);
  }
}
"
`;

exports[`imng-module effects should work 1`] = `undefined`;

exports[`imng-module html file should work 1`] = `
"<kendo-grid (detailExpand)="detailExpanded($event)" [height]="800" kendoGridFocusable [imngODataGrid]="this">
  <ng-template kendoGridToolbarTemplate>
    <div class="w-100 d-flex justify-content-between">
      <h3>Products</h3>
      <imng-kendo-odata-grid-header
        entityName="Product"
        (addItemClicked)="addItem()"
        (reloadEntitiesClicked)="reloadEntities()"
        (resetFiltersClicked)="resetFilters()"
        [hasHiddenColumns$]="hasHiddenColumns$" />
    </div>
  </ng-template>
  <kendo-grid-column [width]="75">
    <ng-template kendoGridCellTemplate let-dataItem let-rowIndex="rowIndex">
      <kendo-menu title="Actions">
        <kendo-menu-item [svgIcon]="icons.menuIcon">
          <kendo-menu-item>
            <ng-template kendoMenuItemLinkTemplate>
              <button
                type="button"
                class="btn btn-sm mx-3 my-2 text-start"
                (click)="editItem(dataItem)"
                placement="left"
                tooltip="Edit">
                <span class="k-icon k-i-edit"></span>
                Edit
              </button>
            </ng-template>
          </kendo-menu-item>
          <kendo-menu-item>
            <ng-template kendoMenuItemLinkTemplate>
              <button
                type="button"
                class="btn btn-sm mx-3 my-2 text-start"
                (click)="deleteItem(dataItem)"
                placement="left"
                tooltip="Delete">
                <span class="k-icon k-i-delete"></span>
                Delete
              </button>
            </ng-template>
          </kendo-menu-item>
        </kendo-menu-item>
      </kendo-menu>
    </ng-template>
  </kendo-grid-column>

  <kendo-grid-column [field]="props.ID" [width]="100" title="Id" filter="text" [hidden]="false">
    <ng-template kendoGridCellTemplate let-dataItem>
      <imng-kendo-copy
        [displayValue]="dataItem[props.ID] | slice:0:5"
        [copyValue]="dataItem[props.ID]" />
    </ng-template>
    <ng-template kendoGridFilterMenuTemplate let-filter>
      <imng-uuid-filter [filter]="filter" />
    </ng-template>
    <ng-template class="header" kendoGridHeaderTemplate let-column>
      <span class="h6" title="Id">Id</span>
    </ng-template>
  </kendo-grid-column>
  <kendo-grid-column [field]="props.NAME" [width]="100" title="Name" filter="text" [hidden]="false">
    <ng-template class="header" kendoGridHeaderTemplate let-column>
      <span class="h6" title="Name">Name</span>
    </ng-template>
  </kendo-grid-column>
  <kendo-grid-column [field]="props.NUM" [width]="100" title="Num" filter="text" [hidden]="false">
    <ng-template class="header" kendoGridHeaderTemplate let-column>
      <span class="h6" title="Num">Num</span>
    </ng-template>
  </kendo-grid-column>
  <kendo-grid-column [field]="props.COLOR" [width]="100" title="Color" filter="text" [hidden]="false">
    <ng-template class="header" kendoGridHeaderTemplate let-column>
      <span class="h6" title="Color">Color</span>
    </ng-template>
  </kendo-grid-column>
  <kendo-grid-column [field]="props.STANDARD_COST" [width]="100" title="Standard Cost" filter="numeric" [hidden]="false">
    <ng-template class="header" kendoGridHeaderTemplate let-column>
      <span class="h6" title="Standard Cost">Standard Cost</span>
    </ng-template>
  </kendo-grid-column>
  <kendo-grid-column [field]="props.LIST_PRICE" [width]="100" title="List Price" filter="numeric" [hidden]="false">
    <ng-template class="header" kendoGridHeaderTemplate let-column>
      <span class="h6" title="List Price">List Price</span>
    </ng-template>
  </kendo-grid-column>
  <kendo-grid-column [field]="props.SIZE" [width]="100" title="Size" filter="text" [hidden]="false">
    <ng-template class="header" kendoGridHeaderTemplate let-column>
      <span class="h6" title="Size">Size</span>
    </ng-template>
  </kendo-grid-column>
  <kendo-grid-column [field]="props.WEIGHT" [width]="100" title="Weight" filter="numeric" [hidden]="false">
    <ng-template class="header" kendoGridHeaderTemplate let-column>
      <span class="h6" title="Weight">Weight</span>
    </ng-template>
  </kendo-grid-column>
  <kendo-grid-column [field]="props.PRODUCT_CATEGORY_ID" [width]="100" title="Product Category Id" filter="text" [hidden]="false">
    <ng-template kendoGridCellTemplate let-dataItem>
      <imng-kendo-copy
        [displayValue]="dataItem[props.PRODUCT_CATEGORY_ID] | slice:0:5"
        [copyValue]="dataItem[props.PRODUCT_CATEGORY_ID]" />
    </ng-template>
    <ng-template kendoGridFilterMenuTemplate let-filter>
      <imng-uuid-filter [filter]="filter" />
    </ng-template>
    <ng-template class="header" kendoGridHeaderTemplate let-column>
      <span class="h6" title="Product Category Id">Product Category Id</span>
    </ng-template>
  </kendo-grid-column>
  <kendo-grid-column [field]="props.PRODUCT_MODEL_ID" [width]="100" title="Product Model Id" filter="text" [hidden]="false">
    <ng-template kendoGridCellTemplate let-dataItem>
      <imng-kendo-copy
        [displayValue]="dataItem[props.PRODUCT_MODEL_ID] | slice:0:5"
        [copyValue]="dataItem[props.PRODUCT_MODEL_ID]" />
    </ng-template>
    <ng-template kendoGridFilterMenuTemplate let-filter>
      <imng-uuid-filter [filter]="filter" />
    </ng-template>
    <ng-template class="header" kendoGridHeaderTemplate let-column>
      <span class="h6" title="Product Model Id">Product Model Id</span>
    </ng-template>
  </kendo-grid-column>
  <kendo-grid-column [field]="props.SELL_START_DATE" [width]="100" format="{0:MM/dd/yy}" title="Sell Start Date" filter="date" [hidden]="false">
    <ng-template class="header" kendoGridHeaderTemplate let-column>
      <span class="h6" title="Sell Start Date">Sell Start Date</span>
    </ng-template>
  </kendo-grid-column>
  <kendo-grid-column [field]="props.SELL_END_DATE" [width]="100" format="{0:MM/dd/yy}" title="Sell End Date" filter="date" [hidden]="false">
    <ng-template class="header" kendoGridHeaderTemplate let-column>
      <span class="h6" title="Sell End Date">Sell End Date</span>
    </ng-template>
  </kendo-grid-column>
  <kendo-grid-column [field]="props.DISCONTINUED_DATE" [width]="100" format="{0:MM/dd/yy}" title="Discontinued Date" filter="date" [hidden]="false">
    <ng-template class="header" kendoGridHeaderTemplate let-column>
      <span class="h6" title="Discontinued Date">Discontinued Date</span>
    </ng-template>
  </kendo-grid-column>
  <kendo-grid-column [field]="props.THUMB_NAIL_PHOTO" [width]="100" title="Thumb Nail Photo" filter="text" [hidden]="false">
    <ng-template class="header" kendoGridHeaderTemplate let-column>
      <span class="h6" title="Thumb Nail Photo">Thumb Nail Photo</span>
    </ng-template>
  </kendo-grid-column>
  <kendo-grid-column [field]="props.CREATED_BY" [width]="100" title="Created By" filter="text" [hidden]="true">
    <ng-template class="header" kendoGridHeaderTemplate let-column>
      <span class="h6" title="Created By">Created By</span>
    </ng-template>
  </kendo-grid-column>
  <kendo-grid-column [field]="props.CREATED_ON_UTC" [width]="100" format="{0:MM/dd/yy HH:mm}" title="Created On Utc" filter="date" [hidden]="true">
    <ng-template class="header" kendoGridHeaderTemplate let-column>
      <span class="h6" title="Created On Utc">Created On Utc</span>
    </ng-template>
  </kendo-grid-column>
  <kendo-grid-column [field]="props.UPDATED_BY" [width]="100" title="Updated By" filter="text" [hidden]="true">
    <ng-template class="header" kendoGridHeaderTemplate let-column>
      <span class="h6" title="Updated By">Updated By</span>
    </ng-template>
  </kendo-grid-column>
  <kendo-grid-column [field]="props.UPDATED_ON_UTC" [width]="100" format="{0:MM/dd/yy HH:mm}" title="Updated On Utc" filter="date" [hidden]="true">
    <ng-template class="header" kendoGridHeaderTemplate let-column>
      <span class="h6" title="Updated On Utc">Updated On Utc</span>
    </ng-template>
  </kendo-grid-column>
  <kendo-grid-column
    [field]="getRelatedField(props.PRODUCT_MODEL, productModelProps.NAME)"
    [width]="100" title="Product Model" filter="text" [hidden]="false">
    <ng-template class="header" kendoGridHeaderTemplate let-column>
      <span class="h6" title="Product Model">Product Model</span>
    </ng-template>
  </kendo-grid-column>
  <kendo-grid-column
    [field]="getRelatedField(props.PRODUCT_CATEGORY, productCategoryProps.NAME)"
    [width]="100" title="Product Category" filter="text" [hidden]="false">
    <ng-template class="header" kendoGridHeaderTemplate let-column>
      <span class="h6" title="Product Category">Product Category</span>
    </ng-template>
  </kendo-grid-column>

  <kendo-grid-pdf [fileName]="getExportFileName('Products')" [allPages]="false">
    <kendo-grid-pdf-margin top="1cm" left="1cm" right="1cm" bottom="1cm" />
  </kendo-grid-pdf>
  <kendo-grid-excel [fileName]="getExportFileName('Products')" [fetchData]="excelData" />
</kendo-grid>
@if (crudFacade.isNewActive$ | async) {
  <aw-product-add />
}
@if (crudFacade.isEditActive$ | async) {
  <aw-product-edit />
}
"
`;

exports[`imng-module list component should work 1`] = `
"import { Component, ChangeDetectionStrategy } from '@angular/core';
import { Router } from '@angular/router';
import { DetailExpandEvent } from '@progress/kendo-angular-grid';
import { KendoODataBasedComponent } from 'imng-kendo-grid-odata';

import { ProductListFacade } from './list.facade';
import { ProductCrudFacade } from '../products-crud';
import { productGridState } from './list.grid-state';

@Component({
  selector: 'aw-product-list',
  templateUrl: './list.component.html',
  styleUrls: ['./list.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush,
  standalone: false,
})
export class ProductListComponent extends KendoODataBasedComponent<IProduct, ProductListFacade> {
  public readonly props = ProductProperties;
  public readonly productModelProps = ProductModelProperties;
  public readonly productCategoryProps = ProductCategoryProperties;
  public currentItem: IProduct | undefined;

  constructor(facade: ProductListFacade,
    public readonly crudFacade: ProductCrudFacade,
    router: Router) {
    super(facade, productGridState, router);
  }

  public addItem(): void {
    this.crudFacade.setCurrentEntity({});
  }

  public editItem(item: IProduct): void {
    this.crudFacade.setCurrentEntity(item);
  }

  public deleteItem(item: IProduct): void {
    this.facade.deleteExistingEntity(item);
  }

  public detailExpanded(evt: DetailExpandEvent): void {
    this.currentItem = evt.dataItem;
  }
}
"
`;

exports[`imng-module module should work 1`] = `
"import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule } from '@angular/forms';
import { StoreModule } from '@ngrx/store';
import { EffectsModule } from '@ngrx/effects';
import { GridModule, ExcelModule, PDFModule } from '@progress/kendo-angular-grid';
import { DialogModule } from '@progress/kendo-angular-dialog';
import { DateInputsModule } from '@progress/kendo-angular-dateinputs';
import { DropDownsModule } from '@progress/kendo-angular-dropdowns';
import { MenusModule } from "@progress/kendo-angular-menu";
import { ImngKendoGridModule } from 'imng-kendo-grid';
import { ImngKendoGridODataModule } from 'imng-kendo-grid-odata';
import { ImngDataEntryDialogModule } from 'imng-kendo-data-entry';
import { ImngKendoGridFilteringModule } from 'imng-kendo-grid-filtering';

import { ProductsRoutingModule } from './products.routing';
import { productsFeature, ProductListEffects, ProductCrudEffects } from './+state';

import { ProductListComponent, ProductListFacade } from './products-list';
import { ProductAddComponent, ProductEditComponent, ProductApiService, ProductCrudFacade  } from './products-crud';


@NgModule({
  declarations: [ProductListComponent, ProductAddComponent, ProductEditComponent ],
  imports: [
    CommonModule,
    GridModule,
    ExcelModule,
    PDFModule,
    DialogModule,
    DateInputsModule,
    DropDownsModule,
    MenusModule,
    ImngDataEntryDialogModule,
    ImngKendoGridFilteringModule,
    ImngKendoGridModule,
    ImngKendoGridODataModule,
    ReactiveFormsModule,
    ProductsRoutingModule,
    StoreModule.forFeature(productsFeature),
    EffectsModule.forFeature([ProductListEffects, ProductCrudEffects]),
  ],
  providers: [
    ProductListFacade,
    ProductCrudFacade,
    ProductApiService, 
  ],
})
export class ProductsModule { }
"
`;

exports[`imng-module reducers should work 1`] = `undefined`;

exports[`imng-module selectors template should work 1`] = `
"import { createSelector } from '@ngrx/store';
import { productsFeature } from './product.feature';
import { isTruthy } from 'imng-ngrx-utils';

const selectIsEditProductActive = createSelector(
  productsFeature.selectCurrentProduct,
  (entity) => isTruthy(entity?.id));
const selectIsNewProductActive = createSelector(
  productsFeature.selectCurrentProduct,
  (entity) => isTruthy(entity) && !isTruthy(entity?.id));
export const productSelectors = {
  selectIsEditProductActive,
  selectIsNewProductActive,
};


"
`;

exports[`imng-module tree files should match 1`] = `
[
  "/test/products-module/+state/index.ts",
  "/test/products-module/+state/product-crud.effects.ts",
  "/test/products-module/+state/product-list.effects.ts",
  "/test/products-module/+state/product.actions.ts",
  "/test/products-module/+state/product.feature.ts",
  "/test/products-module/+state/product.selectors.ts",
  "/test/products-module/products-crud/add-edit.component.html",
  "/test/products-module/products-crud/add-edit.component.scss",
  "/test/products-module/products-crud/add.component.spec.ts",
  "/test/products-module/products-crud/add.component.ts",
  "/test/products-module/products-crud/api.service.ts",
  "/test/products-module/products-crud/base-entry.component.ts",
  "/test/products-module/products-crud/crud.facade.spec.ts",
  "/test/products-module/products-crud/crud.facade.ts",
  "/test/products-module/products-crud/edit.component.spec.ts",
  "/test/products-module/products-crud/edit.component.ts",
  "/test/products-module/products-crud/index.ts",
  "/test/products-module/products-list/index.ts",
  "/test/products-module/products-list/list.component.html",
  "/test/products-module/products-list/list.component.scss",
  "/test/products-module/products-list/list.component.spec.ts",
  "/test/products-module/products-list/list.component.ts",
  "/test/products-module/products-list/list.facade.spec.ts",
  "/test/products-module/products-list/list.facade.ts",
  "/test/products-module/products-list/list.grid-state.ts",
  "/test/products-module/products.module.spec.ts",
  "/test/products-module/products.module.ts",
  "/test/products-module/products.routing.ts",
]
`;

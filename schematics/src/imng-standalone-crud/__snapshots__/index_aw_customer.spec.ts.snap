// Jest Snapshot v1, https://jestjs.io/docs/snapshot-testing

exports[`imng-standalone-crud add component should work 1`] = `
"import {
  Component,
  ChangeDetectionStrategy,
  OnInit,
  OnDestroy,
} from '@angular/core';
import { ImngDataEntryDialogModule } from 'imng-kendo-data-entry';
import { AsyncPipe } from '@angular/common';
import { ReactiveFormsModule } from '@angular/forms';
import { KENDO_DATEPICKER } from '@progress/kendo-angular-dateinputs';
import { KENDO_DROPDOWNS } from '@progress/kendo-angular-dropdowns';
import { CustomerBaseEntryComponent } from './base-entry.component';

@Component({
  selector: 'aw-customer-add',
  imports: [
    AsyncPipe,
    ReactiveFormsModule,
    KENDO_DROPDOWNS,
    KENDO_DATEPICKER,
    ImngDataEntryDialogModule,
  ],
  templateUrl: './add-edit.component.html',
  styleUrls: ['./add-edit.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class CustomerAddComponent extends CustomerBaseEntryComponent implements OnInit, OnDestroy {
  public dialogTitle = 'Add Customer';

  public override initForm(): void {
    super.initForm();
    this.addEditForm.patchValue({});
  }

  public save(): void {
    const val = this.addEditForm.value;
    val.id = undefined;
    this.facade.saveNewEntity(val);
  }
}
"
`;

exports[`imng-standalone-crud add component spec should work 1`] = `
"import { CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA } from '@angular/core';
import { waitForAsync, ComponentFixture, TestBed } from '@angular/core/testing';
import { ReactiveFormsModule } from '@angular/forms';
import { NoopAnimationsModule } from '@angular/platform-browser/animations';
import { DropDownsModule } from '@progress/kendo-angular-dropdowns';
import { createDataEntryMockFacade } from 'imng-kendo-data-entry/testing';
import { mockConsoleError, mockConsoleGroup, mockConsoleWarn, readFirst } from 'imng-ngrx-utils/testing';
import { of } from 'rxjs';

import { CustomerAddComponent } from './add.component';
import { CustomerCrudFacade } from '../customers-ngrx-module/customer.crud.facade';
import { CustomerLookupFacade } from '../customers-ngrx-module/customer.lookup.facade';
import { ICustomer, createTestCustomer, createTestSalesAgent } from '../../models/webapi';

describe('CustomerAddComponent', () => {
  let component: CustomerAddComponent;
  let fixture: ComponentFixture<CustomerAddComponent>;
  let crudFacade: CustomerCrudFacade;
  let lookupFacade: CustomerLookupFacade;
  let consoleWarnMock: jest.SpyInstance<void>;
  let consoleGroupMock: jest.SpyInstance<void>;

  beforeEach(waitForAsync(() => {
    consoleWarnMock = mockConsoleWarn();
    consoleGroupMock = mockConsoleGroup();
    TestBed.configureTestingModule({
      imports: [CustomerAddComponent, ReactiveFormsModule, NoopAnimationsModule, DropDownsModule, ],
      providers: [
        { provide: CustomerCrudFacade, useValue: createDataEntryMockFacade() },
        { provide: CustomerLookupFacade, useValue: {
    salesAgents$: of([ createTestSalesAgent()]),
    loadSalesAgents: jest.fn(),
  } }],
      schemas: [CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA],
    }).compileComponents();
  }));

  beforeEach(() => {
    fixture = TestBed.createComponent(CustomerAddComponent);
    component = fixture.componentInstance;
    crudFacade = component.facade;
    lookupFacade = component.customerLookupFacade;
    fixture.detectChanges();
  });

  afterAll(() => {
    component.ngOnDestroy();
    consoleWarnMock.mockRestore();
    consoleGroupMock.mockRestore();
  });

  test('should create', () => {
    expect(component).toBeTruthy();
    expect(lookupFacade.loadSalesAgents).toHaveBeenCalled();
    
  });

  test('should save', () => {
    component.initForm();
    component.addEditForm?.patchValue(createTestCustomer());
    component.addEditForm.controls.salesAgent?.patchValue(createTestSalesAgent());

    let item: ICustomer | undefined;
    crudFacade.saveNewEntity = jest.fn(x => (item = x));
    crudFacade.updateExistingEntity = jest.fn();
    expect(component.getFormErrors()).toStrictEqual([]);
    component.onSubmit();
    expect(crudFacade.saveNewEntity).toHaveBeenCalledTimes(1);
    expect(crudFacade.updateExistingEntity).toHaveBeenCalledTimes(0);

    expect(item).toMatchSnapshot();
  });

  /**
   * Note: if this test fails, then you're missing validators in your forms.
   * Using form validators is typically a good idea.
   */
  test('should not save', () => {
    const consoleErrorMock = mockConsoleError();
    component.addEditForm?.patchValue({});
    component.onSubmit();
    expect(crudFacade.saveNewEntity).toHaveBeenCalledTimes(0);
    expect(crudFacade.updateExistingEntity).toHaveBeenCalledTimes(0);
    consoleErrorMock.mockRestore();
  });

  test('should cancel', () => {
    crudFacade.clearCurrentEntity = jest.fn();
    component.cancel();
    expect(crudFacade.clearCurrentEntity).toHaveBeenCalledTimes(1);
  });

  test('should support SalesAgent filters', async () => {
    component.handleSalesAgentFilter('xy');
    const result = await readFirst(component.salesAgents$);
    expect(result).toMatchSnapshot();
  });
});
"
`;

exports[`imng-standalone-crud barrel should work 1`] = `
"export { CustomerAddComponent } from './add.component';
export { CustomerEditComponent } from './edit.component';
"
`;

exports[`imng-standalone-crud base component should work 1`] = `
"import { OnInit, Component, inject } from '@angular/core';
import { FormGroup } from '@angular/forms';
import { BaseDataEntryComponent } from 'imng-kendo-data-entry';
import { BehaviorSubject, map, Observable, switchMap } from 'rxjs';

import { CustomerLookupFacade } from '../customers-ngrx-module/customer.lookup.facade';
import { CustomerCrudFacade } from '../customers-ngrx-module/customer.crud.facade';
import { CustomerProperties, ICustomerForm, CustomerFormGroupFac, ISalesAgent, SalesAgentProperties } from '../../models/webapi';

@Component({
  template: '',
})
export abstract class CustomerBaseEntryComponent extends BaseDataEntryComponent<CustomerCrudFacade>
  implements OnInit {
  public readonly customerLookupFacade = inject(CustomerLookupFacade);
  public readonly props = CustomerProperties;
  public readonly salesAgentProps = SalesAgentProperties;
  public readonly salesAgents$: Observable<ISalesAgent[]>;
  public readonly salesAgentFilter$ = new BehaviorSubject('');
  public addEditForm: FormGroup<ICustomerForm>;

  constructor() {
    super(inject(CustomerCrudFacade));
    this.salesAgents$ = this.customerLookupFacade.salesAgents$.pipe(
      switchMap(salesAgents => this.salesAgentFilter$.pipe(
        map(salesAgentFilter => salesAgentFilter ? salesAgents
          .filter(salesAgent => (
            (salesAgent.name && salesAgent.name.toLowerCase().includes(salesAgentFilter)) ||
            (salesAgent.loginId && salesAgent.loginId.toLowerCase().includes(salesAgentFilter))
          )) : salesAgents
    ))));
  }

  public override ngOnInit(): void {
    this.initForm();
    this.customerLookupFacade.loadSalesAgents({ selectors: [
      SalesAgentProperties.ID,
      SalesAgentProperties.NAME,
      SalesAgentProperties.LOGIN_ID,] });
  }

  public initForm(): void {
    this.addEditForm = CustomerFormGroupFac();
  }

  public cancel(): void {
    this.facade.clearCurrentEntity();
  }

  public handleSalesAgentFilter(value: string) {
    this.salesAgentFilter$.next(value.toLowerCase());
  }
}
"
`;

exports[`imng-standalone-crud edit component should work 1`] = `
"import {
  Component,
  ChangeDetectionStrategy,
  OnInit,
  OnDestroy,
} from '@angular/core';
import {
  formGroupPatcher,
  ImngDataEntryDialogModule,
} from 'imng-kendo-data-entry';
import { AsyncPipe } from '@angular/common';
import { ReactiveFormsModule } from '@angular/forms';
import { KENDO_DATEPICKER } from '@progress/kendo-angular-dateinputs';
import { KENDO_DROPDOWNS } from '@progress/kendo-angular-dropdowns';

import { CustomerBaseEntryComponent } from './base-entry.component';

@Component({
  selector: 'aw-customer-edit',
  imports: [
    AsyncPipe,
    ReactiveFormsModule,
    KENDO_DROPDOWNS,
    KENDO_DATEPICKER,
    ImngDataEntryDialogModule,
  ],
  templateUrl: './add-edit.component.html',
  styleUrls: ['./add-edit.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush, 
})
export class CustomerEditComponent extends CustomerBaseEntryComponent implements OnInit, OnDestroy {
  public dialogTitle = 'Edit Customer';

  public override initForm(): void {
    super.initForm();
    this.allSubscriptions.push(this.facade.currentEntity$.pipe(formGroupPatcher(this.addEditForm)).subscribe());
  }

  public save(): void {
    const val = this.addEditForm.value;
    this.facade.updateExistingEntity(val);
  }
}
"
`;

exports[`imng-standalone-crud edit component spec should work 1`] = `
"import { CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA } from '@angular/core';
import { waitForAsync, ComponentFixture, TestBed } from '@angular/core/testing';
import { ReactiveFormsModule } from '@angular/forms';
import { NoopAnimationsModule } from '@angular/platform-browser/animations';
import { DropDownsModule } from '@progress/kendo-angular-dropdowns';
import { createDataEntryMockFacade } from 'imng-kendo-data-entry/testing';
import { mockConsoleError, mockConsoleGroup, mockConsoleWarn, readFirst } from 'imng-ngrx-utils/testing';
import { of } from 'rxjs';

import { CustomerEditComponent } from './edit.component';
import { CustomerCrudFacade } from '../customers-ngrx-module/customer.crud.facade';
import { CustomerLookupFacade } from '../customers-ngrx-module/customer.lookup.facade';
import { ICustomer, createTestCustomer, createTestSalesAgent } from '../../models/webapi';

describe('CustomerEditComponent', () => {
  let component: CustomerEditComponent;
  let fixture: ComponentFixture<CustomerEditComponent>;
  let crudFacade: CustomerCrudFacade;
  let lookupFacade: CustomerLookupFacade;
  let consoleWarnMock: jest.SpyInstance<void>;
  let consoleGroupMock: jest.SpyInstance<void>;

  beforeEach(waitForAsync(() => {
    consoleWarnMock = mockConsoleWarn();
    consoleGroupMock = mockConsoleGroup();
    TestBed.configureTestingModule({
      imports: [CustomerEditComponent, ReactiveFormsModule, NoopAnimationsModule, DropDownsModule, ],
      providers: [
        { provide: CustomerCrudFacade, useValue: createDataEntryMockFacade() },
        { provide: CustomerLookupFacade, useValue: {
    salesAgents$: of([ createTestSalesAgent()]),
    loadSalesAgents: jest.fn(),
  } }],
    schemas: [CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA],
    }).compileComponents();
  }));

  beforeEach(() => {
    fixture = TestBed.createComponent(CustomerEditComponent);
    component = fixture.componentInstance;
    crudFacade = component.facade;
    lookupFacade = component.customerLookupFacade;
    fixture.detectChanges();
  });

  test('should create', () => {
    expect(component).toBeTruthy();
    expect(lookupFacade.loadSalesAgents).toHaveBeenCalled();
    
  });

  afterAll(() => {
    component.ngOnDestroy();
    consoleWarnMock.mockRestore();
    consoleGroupMock.mockRestore();
  });

  test('should update', () => {
    component.initForm();
    component.addEditForm.patchValue(createTestCustomer());
    component.addEditForm.controls.salesAgent.patchValue(createTestSalesAgent());
    let item: ICustomer | undefined;
    crudFacade.updateExistingEntity = jest.fn(x => (item = x));
    expect(component.getFormErrors()).toStrictEqual([]);
    component.onSubmit();
    expect(crudFacade.saveNewEntity).toHaveBeenCalledTimes(0);
    expect(crudFacade.updateExistingEntity).toHaveBeenCalledTimes(1);

    expect(item).toMatchSnapshot();

  });

  /**
   * Note: if this test fails, then you're missing validators in your forms.
   * Using form validators is typically a good idea.
   */
  test('should not update', () => {
    const consoleErrorMock = mockConsoleError();
    component.addEditForm?.patchValue({});
    component.onSubmit();
    expect(crudFacade.saveNewEntity).toHaveBeenCalledTimes(0);
    expect(crudFacade.updateExistingEntity).toHaveBeenCalledTimes(0);
    consoleErrorMock.mockRestore();
  });

  test('should cancel', () => {
    component.cancel();
    expect(crudFacade.clearCurrentEntity).toHaveBeenCalledTimes(1);
  });

  test('should support SalesAgent filters', async () => {
    component.handleSalesAgentFilter('xy');
    const result = await readFirst(component.salesAgents$);
    expect(result).toMatchSnapshot();
  });


});
"
`;

exports[`imng-standalone-crud html should work 1`] = `
"<imng-data-entry-dialog id="dataEntryCustomers" name="dataEntryCustomers" [width]="700" [height]="550" [parentComponent]="this" autoFocusedElement="#num">
  <form id="imng-form" novalidate [formGroup]="addEditForm" autocomplete="off" class="row needs-validation">
    <div class="col-md-6">
      <label for="id" class="control-label">Id: <span class="text-danger">*</span></label>
      <input id="id" type="text" class="form-control" [formControlName]="props.ID" />
      @if ((submitted$ | async) && formControlErrors(props.ID)) {
        <div class="invalid-feedback d-block">
        @if (formControlErrors(props.ID)?.[RequiredError]) {
          <div>Customer id is required</div>
        }
        </div>
      }
    </div>
    <div class="col-md-6">
      <label for="num" class="control-label">Num: <span class="text-danger">*</span></label>
      <input id="num" type="text" class="form-control" [formControlName]="props.NUM" />
      @if ((submitted$ | async) && formControlErrors(props.NUM)) {
        <div class="invalid-feedback d-block">
        @if (formControlErrors(props.NUM)?.[RequiredError]) {
          <div>Customer num is required</div>
        }
        @if (formControlErrors(props.NUM)?.[MinLengthError]) {
          <div>
            Customer num requires a min length of
            {{formMinLengthError(props.NUM)?.requiredLength}}, currently only
            {{formMinLengthError(props.NUM)?.actualLength}}.
          </div>
        }
        </div>
      }
    </div>
    <div class="col-md-6">
      <label for="name" class="control-label">Name:</label>
      <input id="name" type="text" class="form-control" [formControlName]="props.NAME" />
    </div>
    <div class="col-md-6">
      <label for="company_name" class="control-label">Company Name: <span class="text-danger">*</span></label>
      <input id="company_name" type="text" class="form-control" [formControlName]="props.COMPANY_NAME" />
      @if ((submitted$ | async) && formControlErrors(props.COMPANY_NAME)) {
        <div class="invalid-feedback d-block">
        @if (formControlErrors(props.COMPANY_NAME)?.[RequiredError]) {
          <div>Customer company name is required</div>
        }
        @if (formControlErrors(props.COMPANY_NAME)?.[MinLengthError]) {
          <div>
            Customer company name requires a min length of
            {{formMinLengthError(props.COMPANY_NAME)?.requiredLength}}, currently only
            {{formMinLengthError(props.COMPANY_NAME)?.actualLength}}.
          </div>
        }
        </div>
      }
    </div>
    <div class="col-md-6">
      <label for="sales_agent_id" class="control-label">Sales Agent Id: <span class="text-danger">*</span></label>
      <input id="sales_agent_id" type="number" class="form-control" [formControlName]="props.SALES_AGENT_ID" />
      @if ((submitted$ | async) && formControlErrors(props.SALES_AGENT_ID)) {
        <div class="invalid-feedback d-block">
        @if (formControlErrors(props.SALES_AGENT_ID)?.[RequiredError]) {
          <div>Customer sales agent id is required</div>
        }
        </div>
      }
    </div>
    <div class="col-md-6">
      <label for="email_address" class="control-label">Email Address:</label>
      <input id="email_address" type="text" class="form-control" [formControlName]="props.EMAIL_ADDRESS" />
    </div>
    <div class="col-md-6">
      <label for="phone" class="control-label">Phone:</label>
      <input id="phone" type="text" class="form-control" [formControlName]="props.PHONE" />
    </div>
    <div class="col-md-6">
      <label for="sales_agent" class="control-label">Sales Agent:</label>
      <kendo-multicolumncombobox
        id="sales_agent"
        placeholder="Select a sales agent..."
        [formControlName]="props.SALES_AGENT_ID"
        [data]="salesAgents$ | async"
        [textField]="salesAgentProps.NAME"
        [valueField]="salesAgentProps.ID"
        [valuePrimitive]="true"
        [filterable]="true"
        (filterChange)="handleSalesAgentFilter($event)">
          <kendo-combobox-column field="name" title="Name" [width]="100"></kendo-combobox-column>
          <kendo-combobox-column field="loginId" title="Login Id" [width]="100"></kendo-combobox-column>
      </kendo-multicolumncombobox>
    </div>
  </form>
</imng-data-entry-dialog>
"
`;

exports[`imng-standalone-crud scss should work 1`] = `""`;

exports[`imng-standalone-crud tree files should match 1`] = `
[
  "/test/customers-crud/add-edit.component.html",
  "/test/customers-crud/add-edit.component.scss",
  "/test/customers-crud/add.component.spec.ts",
  "/test/customers-crud/add.component.ts",
  "/test/customers-crud/base-entry.component.ts",
  "/test/customers-crud/edit.component.spec.ts",
  "/test/customers-crud/edit.component.ts",
  "/test/customers-crud/index.ts",
]
`;
